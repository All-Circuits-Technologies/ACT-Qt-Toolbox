// SPDX-FileCopyrightText: 2021 - 2024 Benoit Rolandeau <benoit.rolandeau@allcircuits.com>
//
// SPDX-License-Identifier: LicenseRef-ALLCircuits-ACT-1.1

#pragma once

#include <QtGlobal>
#include <QByteArray>

#include "byteutility/endianesshelper.hpp"

class QString;
class QStringRef;


/** @brief Contains helper methods to manage ByteArray */
class ByteArrayHelper
{
    private:
        /** @brief Class constructor */
        ByteArrayHelper() {}

    public:
        /** @brief Parse the hexadecimal string to a QByteArray
            @note The string has to be a hexadecimal number (the case isn't sensitive)
            @note The string accepts the habitual prefixes: "0x" and "0h"
            @note The string accepts the habitual suffix: "h"
            @note The method uses the @ref QByteArray::fromHex method and this method only ignores
                  elements which are not hexadecimal numbers (without returning errors).
                  In our side, we verify if the generated bytearray has a correct size compared to
                  the size of the given hexadecimal string.
                  Because of that, a "glitch" may appears if the hexadecimal size was even and one
                  element isn't correct, for instance:
                  If we receive the following string: "0x0145T3", the method will parse it and
                  create the following byte array: 0x001453, because the 'T' character was ignored
            @param hex The hexadecimal to parse
            @param byteArray The bytearray retrieved (or empty if an error occured)
            @return True if no problem occurs */
        static bool parseFromHex(const QString &hex, QByteArray &byteArray);

        /** @see ByteArrayHelper::parseFromHex */
        static bool parseFromHex(const QStringRef &hex, QByteArray &byteArray);

        /** @brief Parse unsigned integer to a QByteArray
            @param value The value to parse
            @param byteArray The bytearray retrieved
            @param lsbFirst This describes the way the integer is stored in the QByteArray true to
                            store it with LSB first, false with MSB first */
        template<class T>
        static void parseUintToArray(T value, QByteArray &byteArray, bool lsbFirst = false);

        /** @brief Convert a QByteArray to hexadecimal string
            @note The hexadecimal string returned, begins with the prefix: "0x" and it's in
                  lowcase
            @param byteArray The QByteArray to convert to string
            @param hex The hexadecimal string retrieved
            @param prependSuffix If false, no prefix is added to the hexadecimal string
            @param atLeastByteNb This parameter is helpul to add leading 0 if you want to have a
                                 precise byte number.
                                 If -1, nothing is done
                                 If the byte number is above the actual byte array length this
                                 will add leading 0 to the string
                                 If the byte number is under the actual byte array length, this
                                 will do nothing. */
        static void convertToStringHex(const QByteArray &byteArray,
                                       QString &hex,
                                       bool prependSuffix = true,
                                       int atLeastByteNb = -1);

        /** @brief Convert a QByteArray to hexadecimal string
            @note The hexadecimal string returned, begins with the prefix: "0x" and it's in
                  lowcase
            @param byteArray The QByteArray to convert to string
            @param prependSuffix If false, no prefix is added to the hexadecimal string
            @param atLeastByteNb This parameter is helpul to add leading 0 if you want to have a
                                 precise byte number.
                                 If -1, nothing is done
                                 If the byte number is above the actual byte array length this
                                 will add leading 0 to the string
                                 If the byte number is under the actual byte array length, this
                                 will do nothing.
            @return The hexadecimal string retrieved */
        static QString toStringHex(const QByteArray &byteArray,
                                   bool prependSuffix = true,
                                   int atLeastByteNb = -1);

        /** @brief Convert a QByteArray to an unsigned integer
            @note The QByteArray lenght can't exceed the quint16 size (2 bytes) or an error will be
                  returned
            @param byteArray The byte array to parse
            @param hexValue The unsigned integer parsed
            @param lsbFirst This describes the way the integer is stored in the QByteArray true if
                            it' with's LSB first, false if it's MSB first
            @return True if no problem occurs */
        static bool toUintHex(const QByteArray &byteArray,
                              quint16 &hexValue,
                              bool lsbFirst = false);

        /** @brief Convert a QByteArray to an unsigned integer
            @note The QByteArray lenght can't exceed the quint32 size (4 bytes) or an error will be
                  returned
            @param byteArray The byte array to parse
            @param hexValue The unsigned integer parsed
            @param lsbFirst This describes the way the integer is stored in the QByteArray true if
                            it' with's LSB first, false if it's MSB first
            @return True if no problem occurs */
        static bool toUintHex(const QByteArray &byteArray,
                              quint32 &hexValue,
                              bool lsbFirst = false);

        /** @brief Convert a QByteArray to an unsigned integer
            @note The QByteArray lenght can't exceed the quint64 size (8 bytes) or an error will be
                  returned
            @param byteArray The byte array to parse
            @param hexValue The unsigned integer parsed
            @param lsbFirst This describes the way the integer is stored in the QByteArray true if
                            it' with's LSB first, false if it's MSB first
            @return True if no problem occurs */
        static bool toUintHex(const QByteArray &byteArray,
                              quint64 &hexValue,
                              bool lsbFirst = false);

        /** @brief Calculate the max integer size from the byte size given
            @param byteCount The byte size to get its max size
            @param maxUnsignedValue The max size calculated
            @return True if no problem occurs */
        static bool calculateMaxUnsignedValue(quint8 byteCount, quint64 &maxUnsignedValue);

        /** @brief Applies an OR operand on each byte of the given arrays and creates a new byte
                   array with the result
            @param a1 The first byte array to apply operand on
            @param a2 The second byte array to apply operand on
            @return The result of the operand */
        static QByteArray operatorOr(const QByteArray &a1,
                                     const QByteArray &a2);

        /** @brief Applies an OR operand on each byte of the given arrays and creates a new byte
                   array with the result.
            @note The given offsets are used to indicate that the arrays have to be seen as a part
                  of a bigger array.
            @param a1 The first byte array to apply operand on
            @param a2 The second byte array to apply operand on
            @param offsetA1 This is the offset of the @ref a1 array in a bigger array
            @param offsetA2 This is the offset of the @ref a2 array in a bigger array
            @return First part of the QPair is the result of the operand, second part is the offset
                    of the result in the bigger array */
        static QPair<QByteArray, quint8> operatorOr(const QByteArray &a1,
                                                    const QByteArray &a2,
                                                    quint8 offsetA1,
                                                    quint8 offsetA2);

        /** @brief Applies an OR operand on each byte of the given arrays and creates a new byte
                   array with the result.
            @note The given offsets are used to indicate that the arrays have to be seen as a part
                  of a bigger array.
            @note The @ref aList elements have to match the @ref offsetAList elements at same index
            @param aList The byte array list to apply operand on
            @param offsetAList The offset list of the @ref aList array in a bigger array
            @return First part of the QPair is the result of the operand, second part is the offset
                    of the result in the bigger array */
        static QPair<QByteArray, quint8> operatorOr(const QVector<QByteArray> &aList,
                                                    const QVector<quint8> &offsetAList);

        /** @brief Applies a XOR operand on each byte of the given arrays and creates a new byte
                   array with the result
            @param a1 The first byte array to apply operand on
            @param a2 The second byte array to apply operand on
            @return The result of the operand */
        static QByteArray operatorXor(const QByteArray &a1,
                                      const QByteArray &a2);

        /** @brief Applies a XOR operand on each byte of the given arrays and creates a new byte
                   array with the result.
            @note The given offsets are used to indicate that the arrays have to be seen as a part
                  of a bigger array.
            @param a1 The first byte array to apply operand on
            @param a2 The second byte array to apply operand on
            @param offsetA1 This is the offset of the @ref a1 array in a bigger array
            @param offsetA2 This is the offset of the @ref a2 array in a bigger array
            @return First part of the QPair is the result of the operand, second part is the offset
                    of the result in the bigger array */
        static QPair<QByteArray, quint8> operatorXor(const QByteArray &a1,
                                                     const QByteArray &a2,
                                                     quint8 offsetA1,
                                                     quint8 offsetA2);

        /** @brief Applies a XOR operand on each byte of the given arrays and creates a new byte
                   array with the result.
            @note The given offsets are used to indicate that the arrays have to be seen as a part
                  of a bigger array.
            @note The @ref aList elements have to match the @ref offsetAList elements at same index
            @param aList The byte array list to apply operand on
            @param offsetAList The offset list of the @ref aList array in a bigger array
            @return First part of the QPair is the result of the operand, second part is the offset
                    of the result in the bigger array */
        static QPair<QByteArray, quint8> operatorXor(const QVector<QByteArray> &aList,
                                                     const QVector<quint8> &offsetAList);

        /** @brief Applies an AND operand on each byte of the given arrays and creates a new byte
                   array with the result
            @param a1 The first byte array to apply operand on
            @param a2 The second byte array to apply operand on
            @return The result of the operand */
        static QByteArray operatorAnd(const QByteArray &a1,
                                      const QByteArray &a2);

        /** @brief Applies an AND operand on each byte of the given arrays and creates a new byte
                   array with the result.
            @note The given offsets are used to indicate that the arrays have to be seen as a part
                  of a bigger array.
            @param a1 The first byte array to apply operand on
            @param a2 The second byte array to apply operand on
            @param offsetA1 This is the offset of the @ref a1 array in a bigger array
            @param offsetA2 This is the offset of the @ref a2 array in a bigger array
            @return First part of the QPair is the result of the operand, second part is the offset
                    of the result in the bigger array */
        static QPair<QByteArray, quint8> operatorAnd(const QByteArray &a1,
                                                     const QByteArray &a2,
                                                     quint8 offsetA1,
                                                     quint8 offsetA2);

        /** @brief Applies an AND operand on each byte of the given arrays and creates a new byte
                   array with the result.
            @note The given offsets are used to indicate that the arrays have to be seen as a part
                  of a bigger array.
            @note The @ref aList elements have to match the @ref offsetAList elements at same index
            @param aList The byte array list to apply operand on
            @param offsetAList The offset list of the @ref aList array in a bigger array
            @return First part of the QPair is the result of the operand, second part is the offset
                    of the result in the bigger array */
        static QPair<QByteArray, quint8> operatorAnd(const QVector<QByteArray> &aList,
                                                     const QVector<quint8> &offsetAList);

        /** @brief Applies a NOT operation on each bytes of the given array and create a new byte
                   array with the result
            @param byteArray The first byte array to apply operand on
            @return The result of the operand */
        static QByteArray operatorNot(const QByteArray &byteArray);

        /** @brief Test if some bits are colliding between each others.
            @note The method stops at the first collision detected
            @param a1 The first byte array to test collision on
            @param a2 The second byte array to test collision on
            @return True if at least one collision has been detected */
        static bool testIfCollidingBits(const QByteArray &a1,
                                        const QByteArray &a2);

        /** @brief Test if some bits are colliding between each others.
            @note The method stops at the first collision detected
            @param a1 The first byte array to test collision on
            @param a2 The second byte array to test collision on
            @param offsetA1 This is the offset of the @ref a1 array in a bigger array
            @param offsetA2 This is the offset of the @ref a2 array in a bigger array
            @return True if at least one collision has been detected */
        static bool testIfCollidingBits(const QByteArray &a1,
                                        const QByteArray &a2,
                                        quint8 offsetA1,
                                        quint8 offsetA2);

        /** @brief Test if some bits are colliding between each others.
            @note The method stops at the first collision detected
            @param aList The byte array list to test collision on
            @param offsetAList The offset list of the @ref aList array in a bigger array
            @return True if at least one collision has been detected */
        static bool testIfCollidingBits(const QVector<QByteArray> &aList,
                                        const QVector<quint8> &offsetAList);

        /** @brief Test if the given QByteArray only contains 0x00 bytes
            @param byteArray The byteArray to test
            @return True if the byte array contains only 0x00 bytes */
        static bool equalsToZero(const QByteArray &byteArray);

        /** @brief Applies an operation on each byte of the given arrays and creates a new byte
                   array with the result.
            @note The given offsets are used to indicate that the arrays have to be seen as a part
                  of a bigger array.
            @note The @ref aList elements have to match the @ref offsetAList elements at same index
            @note The method may only return false, if the @ref operatorFunc may return false.
                  If the @ref operatorFunc given can't never return false, the method will always
                  return true.
            @param aList The byte array list to apply operand on
            @param offsetAList The offset list of the @ref aList array in a bigger array
            @param initialValue The initial value to apply before calling the @ref operatorFunc on
                                each bytes
            @param operatorFunc The function to call on each bytes. Return false, if a problem
                                occurred.
            @param finalResult If not null: first part of the QPair is the result of the operand,
                               second part is the offset of the result in the bigger array
            @return True if no problem occurred when calling @ref operatorFunc function */
        static bool logicOperator(
            const QVector<QByteArray> &aList,
            const QVector<quint8> &offsetAList,
            quint8 initialValue,
            const std::function<bool (quint8 a1, quint8 a2, quint8 &result)> &operatorFunc,
            QPair<QByteArray, quint8>* finalResult = nullptr);

    private:
        /** @brief Extract the usable hexacedimal part of the string (remove the suffix or prefix,
                   if it exists)
            @note The method uses the @ref QByteArray::fromHex method and this method only ignores
                  elements which are not hexadecimal numbers (without returning errors).
                  In our side, we verify if the generated bytearray has a correct size compared to
                  the size of the given hexadecimal string.
                  Because of that, a "glitch" may appears if the hexadecimal size was even and one
                  element isn't correct, for instance:
                  If we receive the following string: "0x0145T3", the method will parse it and
                  create the following byte array: 0x001453, because the 'T' character was ignored
            @param hex The hexadecimal to process
            @param testStart If true, it verifies if the extra element is at the start of the
                                hexadecimal string.
                             If false, it verifies at the end of the string
            @param extraElem The extra element to search in the given string
            @param hexPart The hexadecimal string extracted
            @return True if no problem occurs */
        static bool extractHexPart(const QStringRef &hex,
                                   bool testStart,
                                   const QString &extraElem,
                                   QStringRef &hexPart);

        /** @brief Parse unsigned integer to byte array
            @note T can be a quint16, quint32 or quint64
            @param value The unsigned integer value to parse
            @param byteNb The number of bytes contains in the parsed integer
            @param byteArray The byte array got from the unsigned integer
            @param lsbFirst This describes the way the integer is stored in the QByteArray true to
                            store it with LSB first, false with MSB first */
        template<class T>
        static void parseUintToArray(T value,
                                     quint8 byteNb,
                                     QByteArray &byteArray,
                                     bool lsbFirst);

        /** @brief Fill the given list with the byte contains in the given byte array
            @note The list is filled with the LSB first
            @note If the QByteArray size is under the one wanted, the list will be completed with
                  zeros
            @note Returns false if the byte array length is greather than the length wanted
            @param byteArray The byte array to parse
            @param lsbFirst This describes the way the integer is stored in the QByteArray true if
                            it' with's LSB first, false if it's MSB first
            @param lengthWanted The wanted length for the list
            @param lsbFirstList The list which contains all the bytes ordered by LSB first
            @return True if no problem occurs
                    False if the length of the @ref QByteArray is larger than the length wanted */
        static bool fillByteListLsbFirst(const QByteArray &byteArray,
                                         bool lsbFirst,
                                         int lengthWanted,
                                         QVector<quint8> &lsbFirstList);

    private:
        static const QString hexPrefixC;
        static const QString hexPrefixTi;
        static const QString hexSuffix;
};

template<>
inline void ByteArrayHelper::parseUintToArray(quint16 value, QByteArray &byteArray, bool lsbFirst)
{
    parseUintToArray(value, EndianessHelper::ByteNbInUint16, byteArray, lsbFirst);
}

template<>
inline void ByteArrayHelper::parseUintToArray(quint32 value, QByteArray &byteArray, bool lsbFirst)
{
    parseUintToArray(value, EndianessHelper::ByteNbInUint32, byteArray, lsbFirst);
}

template<>
inline void ByteArrayHelper::parseUintToArray(quint64 value, QByteArray &byteArray, bool lsbFirst)
{
    parseUintToArray(value, EndianessHelper::ByteNbInUint64, byteArray, lsbFirst);
}

template<class T>
void ByteArrayHelper::parseUintToArray(T value,
                                       quint8 byteNb,
                                       QByteArray &byteArray,
                                       bool lsbFirst)
{
    static_assert (std::is_same<quint64, T>() ||
                   std::is_same<quint32, T>() ||
                   std::is_same<quint16, T>(), "The value is not an unsigned integer");

    byteArray.resize(byteNb);

    for(quint8 idx = 0; idx < byteNb; idx++)
    {
        int byteIdx = idx;

        if(!lsbFirst)
        {
            byteIdx = (byteNb - 1) - idx;
        }

        byteArray[idx] = static_cast<char>(EndianessHelper::getByteFromLsbToMsb(value, byteIdx));
    }
}
